# -*- coding: utf-8 -*-
"""T1_Instru_II.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kYJMf3XQ2jCsXivjYvAvFKPhKtx7XUJu

**Tarea 1 / Instrumentación II**

**Estudiantes:**

Fabián Díaz Sánchez

Brandon Obregón Garita
"""

import pandas as pd
from matplotlib import pyplot as plt

def sar(signal, bit, m_v=5):  # Definición de función, range default = 5 V
    b_data, bits = [], 0b1 << bit  # Definir almacenaje de datos y binario con bits solicitados

    for i in signal:  # Recorre la lista de señales
        b_a = 1 << (bit - 1)  # Definir número de prueba inicial

        for j in range(1, bit+1):  # SAR
            d_v = m_v * b_a / bits  # Aproximación base

            if d_v < i and j < bit:   # Compara si el valor aproximado es mayor al input
                b_a = b_a | (1 << (bit - 1) - j)  # De ser correcto aumenta el siguiente bit. p.ej. 1000 -> 1100

            elif d_v > i and j <= bit:  # Si la aproximación es mayor entonces debe de devolver resetear los bits
                if b_a > (0b1 << bit-1) or (d_v - i) > 0:  # En 4 bits, si es mayor a 8, entonces: 1100 -> 1010
                    if j == bit:  # Caso específico para 0000
                        b_a = b_a & ~(1 << bit - j)
                    else:  # Caso general
                        b_a = b_a & ~(1 << bit - j) | (1 << (bit-1) - j)
                elif b_a < (0b1 << bit-1) or (d_v - i) < 0:  # Si es menor a 8, entonces de 1000 -> 0100
                    b_a = b_a & ~(1 << (bit+1) - j) | (1 << bit - j)

        b_data.append(m_v * b_a / bits)  # Después de iteración agrega el valor más próximo
    return b_data

  # Input data & declare variable
adc = pd.read_csv('https://raw.githubusercontent.com/BrandonOG13/TareasInstru/main/adc.csv')
t, s = list(adc["t"]), list(adc["s"])

# Data acquisition
data_2 = sar(s, 2)
data_4 = sar(s, 4)
data_6 = sar(s, 6)
data_8 = sar(s, 8)

# Plot data
plt.plot(adc.t, adc.s)
plt.plot(adc.t, data_2)
plt.plot(adc.t, data_4)
plt.plot(adc.t, data_6)
plt.plot(adc.t, data_8)

plt.title('Succesive Aproximation Register')
plt.ylabel('Voltage')
plt.xlabel('Time (s)')
plt.legend(['Analog', '2 Bits', '4 Bits', '6 Bits', '8 Bits'], loc='lower left')
plt.show()

ran = 5

R_2, R_4, R_6, R_8 = ran/(2**2-1), ran/(2**4-1), ran/(2**6-1), ran/(2**8-1)

eq_2 = R_2/2
eq_4 = R_4/2
eq_6 = R_6/2
eq_8 = R_8/2
print("Los errores de cuantización para los distintos casos son:")
print("Para 2 bits:","|eq|<=" ,eq_2)
print("Para 4 bits:","|eq|<=" ,eq_4)
print("Para 6 bits:","|eq|<=" ,eq_6)
print("Para 8 bits:","|eq|<=" ,eq_8)